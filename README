OCP KATA BOWLING

Il seguente sito calcola il punteggio del bowling, puo' fare da oracolo se qualcosa non torna:
http://tralvex.com/pub/bowling/BSC.htm

Per chi ha linux e mono, probabilmente e' sufficiente compilare tutti i .cs creando un assmebly (.dll) e lanciare nunit dandogli come argomento l'assembly stesso.

Da dot.net framework e' necessario aver aggiunto uno degli assembly di nunit (credo il core) nella gac, per poter lanciare nunit stesso. Da mono non saprei.

Ho esplicitato il concetto di Frame anche nei test (che sono da rifattorizzare).
Mi era piu' chiaro cosi' che concentrandomi sul singolo lancio/rollata.

C'e' qualcosa di smelloso, come il fatto di avere esteso la classe Frame in LastFrame per indicare un frame che potenzialmente puo' avere fino a tre slot anziche' solo due. Il decimo frame, che prevede fino a tre lanci possibili.

Incidentalmente questo ha necessitato un controllo di class checking che e' di solito e' considerato ancor piu' pericoloso del subclassing, pero' curiosamente in questo caso e' molto "parlante", visto che la condizione viene verificata con la sintassi

if (frames[i] is LastFrame ) ... (per dire che nell'ultimo frame le regole sono un po' diverse)

Comuqnue credo sia da rifattorizzare, per esempio usando un'interfaccia frame che preveda un numero variabile di rollate.
Con questo riconduco ad un discorso OCP anche il concetto di frame.

Ho indicato un po' di vincoli tramite precondizioni attraverso un framework leggero di dbc.

Esempio: un frame che ha 10 birilli abbattuti nel primo lancio, non puo' avere un secondo lancio.
Un LastFrame che non abbatte10 birilli al secondo lancio,  non ne puo' avere uno ulteriore, e analogamente se il secondo non abbatte 10 birilli, non ne puo' avere uno ulteriore.
Le precondizioni di LastFrame violano il dbc stesso, e quindi anche LSP.

Non conosco le regole del bowling marziano e venusiano, ma dubito che l'implementazione proposta sia gia' chiusa rispetto a queste due varianti.


